Para realizar la implementación se ha optado por utilizar el lenguaje de programación $Python$, en
su versión 3, concretamente, en el momento de la realización de este trabajo el desarrollo se ha realizado
bajo la versión 3.6.2 de dicho lenguaje.

$Python$ es un lenguaje multiparadigma que es ampliamente utilizado en ámbitos científicos y de investigación.
Cuenta con multitud de herramientas para la realización de $tests$, gestión de dependencias, etc., entre las
que se encuentran $Unittest$ y $Pip$, que han sido empleadas en este trabajo.

Como librerías se han empleado $Numpy$ y $Matplotlib$, las cuales, son casi un estándar dentro
del mundo $Python$.

Para el desarrollo de este proyecto se ha optado por implementar la solución en orientado a objeto
en su mayoría. El programa cuenta con un único punto de entrada, en este caso, siguendo el patrón
\textit{Singleton}.

En este punto de entrada, se establecen los valores de los parámetros por defecto que se desean
para cada ejecución. Por defecto, el programa utiliza los valores por defectos establecidos en
uno de los módulos en los que se divide el proyecto, y que se comentarán más adelante. Dichos valores,
coinciden con los valores por defectos que se presentan en el artículo.

En este caso, el programa cuenta con 6 módulos. El módulo principal, \textit{automata.py} presenta
una clase que sigue el patrón \textit{Estrategia} y, el cual, engloba la función principal de ejecución,
así como, el resto de funciones necesarias para su correcta ejecución. Además, importa y utiliza
el resto de módulos, los caules, se describen a continuación.

\section{Módulo \textit{genome.py}}

En este módulo se presenta la clase que continen como propiedades las cinco variables
binarias que representan la activación o no de determinadas mutaciones cancerosas, así como,
algunas funciones de utilidad para la simulación referentes al genoma.

Completar.

\section{Módulo \textit{simulation\_globals.py}}

Este módulo, contiene los valores, así como, la clase necesaria para su almacenaje, para
los parámetros que intervienen en la simulación. Contiene la definición de constantes que
representan dichos valores junto a sus valores por defecto.

Además, contiene otra serie de valores como constantes que son necesarios y que no forman parte de la
clase \textit{SimulationGlobals} y que no son suceptibles de variar.

\section{Módulo \textit{cell.py}}

El módulo \textit{cell.py} cuenta con una clase que modela la célula. Utiliza la composición
para incluir el objeto \textit{Genome} frente al uso de la herencia, lo cual, presenta ventajas
de cara a la refactorización.

Cuenta, además de con el objeto \textit{Genome}, con algunas propiedades extra, como por ejemplo,
el tamaño del telómero ($tl$) y la tasa de mutación base ($m$) para cada célula.

Finalmente, presenta algunos métodos necesarios en la simulación para interactuar con la célula.

\section{Módulo \textit{experiments.py}}

En este módulo, se encuentran las funciones que se utilizan en el módulo
\textit{automata.py} para realizar los experimentos o pruebas previas a la mitosis. Estos son:

\begin{itemize}
  \item \textit{random\_death\_test()}: Prueba que indica si hay o no muerte aleatoria de la célula.
  \item \textit{random\_death\_test(n, ea)}: Prueba que indica si hay muerte por daño genético según
  el número de mutaciones de la célula que está realizando el proceso de mitosis, excepto que esté
  presente el marcador con la mutación que permite evadir la apoptosis.
  \item \textit{random\_death\_test(sg, spatial\_boundary)}: Prueba que está dentro del
  límite espacial o, lo que es lo mismo, si existe suficiente factor de crecimiento como
  para ejecutar la mitosis. Excepto, si tiene presente el marcador $sg$, que permite
  ejecutar la mitosis si la célula se encuentra fuera de dicho espacio.
  \item \textit{random\_death\_test(igi)}: Prueba que comprueba si existe espacio para ubicar la célula
  hija una vez realizada la mitosis. Si no hay espacio y la célula tiene la mutación asociada al
  marcador $igi$, podrá matar a un vecino para ubicar a la célula hija.
  \item \textit{random\_death\_test(tl, ei)}: Prueba que comprueba si el telómero tiene tamaño
  mayor a $0$ para realizar la mitosis. Si el tamaño es $0$, la célula puede realizar mitosis
  si tiene presente la mutación asociada al marcador $ei$.
\end{itemize}

\section{Módulo \textit{grid.py}}

El módulo \textit{grid.py} se encarga, en primer lugar, de almacenar las dimensiones de la
rejilla. En segundo lugar, tiene las funciones necesarias para obtener un vecindario en
tres dimensiones, comprobando que no excede los límites de la rejilla. En tercer lugar, contiene
una función que filtra las posiciones de un vecindario dado para devolver un objeto que contiene
las posiciones filtradas en función de si estas se encuentran ocupadas o no.

Por último, contiene funciones para construir una rejilla en tres dimensiones utilizando
la librería \textit{numPy}, para ser utilizada posteriormente junto a \textit{matplotlib}
para renderizar dicho cubo.

\section{Módulo \textit{automata.py}}

Módulo principal del sistema que contiene la lógica de ejecución del mismo. El sistema
está diseñado siguiendo el patrón \textit{Singleton}, es decir, sólo hay un objeto
autómata que, implementando el patrón \textit{estrategia}, tiene un, método con
la lógica de ejecución.

La lógica de ejecución se encuentra descrita en la sección 4.8 de este documento.

Además, tiene como atributos la agenda de eventos mitóticos, así como, el objeto que
encapsula los experimentos necesarios para saber si se aplica o no mitosis a cada célula, los
parámetros de simulación, el objeto con la lógica necesaria para gestionar la rejilla y, por último,
la responsabilidad de generar las medidas utilizando el módulo de analítica que se describe a continuación.

\section{Módulo \textit{analytics.py}}

Este último módulo, reune las funciones necesarias para hacer medidas sobre las células
de la rejilla, como por ejemplo, células sanas o cancerígenas, cuántas células tienen un
determinado marcador del cáncer activo, etc.

Además, contiene funciones para construir y mostrar gráficas con vista a presentar la evolución
del sistema a lo largo de la simulación.
